<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.6.1/firebase.js"></script>
<script src="//cdn.quilljs.com/1.3.6/quill.min.js"></script>

<script>
  let quill;
  let state = {
      rangeA1: null,
      key: null,
      error: null,
      // TODO: use Sheet ID
      sheetName: null,
      dbSheet: null,
      prevNote: null,
      currentNote: null,
  };

  function debounce(callback, wait) {
      let timerId;
      return (...args) => {
          clearTimeout(timerId);
          timerId = setTimeout(() => {
              callback(...args);
          }, wait);
      };
}

  function init() {
      if (!$('#editor').size()) {
          window.requestAnimationFrame(init);
      } else {
          quill = new Quill('#editor', {
              modules: {
                  toolbar: '#editor-toolbar',
              },
              placeholder: 'Write some notes...',
              theme: 'snow',
          });
          quill.on(
              'text-change',
              debounce((delta, oldDelta, source) => {
                  //   if user, submit, if api, ignore
                  console.log('text changed', {delta, oldDelta, source});
                  if (source === 'user') {
                      handleFormSubmit();
                  }
              }, 1000)
          );
          google.script.run
              .withSuccessHandler((data) => {
                  state.rangeA1 = data.rangeA1;
                  state.key = data.key;
                  state.error = data.error;
                  state.sheetName = data.sheetName;
                  state.dbSheet = data.dbSheet;
                  state.prevNote = data.prevNote;
                  state.currentNote = data.currentNote;
              })
              .withFailureHandler((error) => {
                  console.log({error});
                  state.error = error.message;
              })
              .initializeState();
          poll();
      }
  }

  init();

  function setAlive() {
      var isSidebar = document.getElementById('isSidebar').innerHTML == 'true';
      if (!isSidebar) {
          google.script.run.setAlive();
      }
  }

function checkAlive() {
      var isSidebar = document.getElementById('isSidebar').innerHTML == 'true';
      if (isSidebar) {
          google.script.run
              .withSuccessHandler(function (result) {
                  //document.getElementById("lastPoll").innerHTML = result;
                  //   if (result == 'false') {
                  //       document.getElementById('shouldPoll').innerHTML = 'false';
                  //   } else {
                  //       document.getElementById('shouldPoll').innerHTML = 'true';
                  //   }
              })
              .withFailureHandler(function (msg, element) {
                  //google.script.run.showAlert("Couldn't open sidebar editor",msg);
              })
              .getAlive();
      }
}

  function handleFormSubmit() {
      //   displayMessage('Saving...');
      const currentNoteContent = quill.root.innerHTML;
      const currentNoteLength = quill.getLength();
      const key = state.key;
      const range = state.rangeA1;
      const sheetName = state.sheetName;
      const dbSheet = state.dbSheet;
      if (currentNoteLength < 50000) {
          google.script.run
              .withSuccessHandler(() => console.log('a'))
              //   .withFailureHandler((e) => {
              //       console.log('error getting text input');
              //       console.log(e);
              //   })
              .getTextInput(key, sheetName, range, currentNoteContent, dbSheet);
      } else {
          //   displayMessage("Can't save. Cell note is too long!");
      }
  }

  function updateCellRange() {
      const dbSheet = state.dbSheet;
      const currentNoteContent = quill.root.innerHTML;
      state.currentNote = JSON.stringify(currentNoteContent);
      if (currentNoteContent) {
          try {
              google.script.run
                  .withSuccessHandler(function (data, element) {
                      if (data) {
                          const splitter = data.split('!@!@');
                          const [
                              key,
                              content,
                              sheetName,
                              rangeA1formatted,
                              error,
                          ] = splitter;
                          //   const oldError = document.getElementById('error').innerHTML;
  
                          //   displayError(error == 'true', oldError != error);
                          //   document.getElementById('error').innerHTML = error;
                          state.key = key;
                          state.sheetName = sheetName;
                          state.rangeA1 = rangeA1formatted;
                          state.error = error || null;
                          state.prevNote = content;
                          state.currentNote = content;

                          quill.setContents(quill.clipboard.convert(content));
                          //CKEDITOR.instances.editor1.setData(content);
                          //   displayMessage('');
                      }
                  })
                  .withFailureHandler(function (msg, element) {
                      // code to execute if data was not gotten ok
                  })
                  .getNoteForActiveRange(dbSheet);
          } catch (err) {
              console.error(err);
          }
      }
      poll();
  }

  /**
   * Poll a server-side function at the given interval, to have
   * results passed to a successHandler callback. There's no other
   * means to determine if the user has made changes (namely, changes
   * to cell selection) in client-side code.
   *
   * https://stackoverflow.com/a/24773178/1677912
   *
   * @param {Number} interval   (optional) Time in ms between polls.
   *                            Default is 2s (2000ms)
   */
  function poll(interval) {
      /**
       * TODO: there may be a better way to do this using Quill's editor-change callback;
       * listen for changes in the editor to determine if we should write to the DB; not
       * do it on a polled interval (reading from the DB based on cell selection will likely
       * have to remain in a polling interval)
       * */
      console.log({state});
      interval = interval || 2000;

      setTimeout(function () {
          updateCellRange();
      }, interval);
  
      setTimeout(function () {
          checkAlive();
          setAlive();
      }, 5000);
  }
</script>

