<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.6.1/firebase.js"></script>
<script src="//cdn.quilljs.com/1.3.6/quill.min.js"></script>

<script>
  let quill;
  let state = {
      rangeA1: null,
      key: null,
      error: null,
      // TODO: use Sheet ID
      sheetName: null,
      dbSheet: null,
      prevNote: null,
      currentNote: null,
  };

  function debounce(callback, wait) {
      let timerId;
      return (...args) => {
          clearTimeout(timerId);
          timerId = setTimeout(() => {
              callback(...args);
          }, wait);
      };
}

  function init() {
      if (!$('#editor').size()) {
          window.requestAnimationFrame(init);
      } else {
          quill = new Quill('#editor', {
              modules: {
                  toolbar: '#editor-toolbar',
              },
              placeholder: 'Write some notes...',
              theme: 'snow',
          });
          quill.on(
              'text-change',
              debounce((delta, oldDelta, source) => {
                  //   if user, submit, if api, ignore
                  console.log('text changed', {delta, oldDelta, source});
                  if (source === 'user') {
                      handleFormSubmit();
                  }
              }, 1000)
          );
          document.getElementById('editor-expand').onclick = fullSize;
          google.script.run
              .withSuccessHandler((data) => {
                  state.rangeA1 = data.rangeA1;
                  state.key = data.key;
                  state.error = data.error;
                  state.sheetName = data.sheetName;
                  state.dbSheet = data.dbSheet;
                  state.prevNote = data.prevNote;
                  state.currentNote = data.currentNote;
              })
              .withFailureHandler((error) => {
                  console.log({error});
                  state.error = error.message;
              })
              .initializeState();
          poll({firstPoll: true});
      }
  }

  init();

  function setStatusText(text) {
      document.getElementById('status').innerHTML = text;
  }

  let currentMessageResetId = null;
  function displayMessage(message, {timeout} = {timeout: 3000}) {
      if (currentMessageResetId) {
          clearTimeout(currentMessageResetId);
      }

      setStatusText(message);

      currentMessageResetId = setTimeout(() => {
          setStatusText('');
      }, timeout);
  }

  function fullSize() {
      console.log('full size');
      google.script.run
          .withSuccessHandler(function () {})
          .withFailureHandler(function (msg, element) {
              google.script.run.showAlert("Couldn't open full size editor", msg);
          })
          .showExpandedSideNotes();
  }

  function setAlive() {
      var isSidebar = document.getElementById('isSidebar').innerHTML == 'true';
      if (!isSidebar) {
          google.script.run.setAlive();
      }
  }

  function checkAlive() {
      var isSidebar = document.getElementById('isSidebar').innerHTML == 'true';
      if (isSidebar) {
          google.script.run
              .withSuccessHandler(function (result) {
                  //document.getElementById("lastPoll").innerHTML = result;
                  //   if (result == 'false') {
                  //       document.getElementById('shouldPoll').innerHTML = 'false';
                  //   } else {
                  //       document.getElementById('shouldPoll').innerHTML = 'true';
                  //   }
              })
              .withFailureHandler(function (msg, element) {
                  //google.script.run.showAlert("Couldn't open sidebar editor",msg);
              })
              .getAlive();
      }
}

  function handleFormSubmit() {
      displayMessage('Saving...');
      const currentNoteContent = quill.root.innerHTML;
      const key = state.key;
      const range = state.rangeA1;
      const sheetName = state.sheetName;
      const dbSheet = state.dbSheet;
      if (currentNoteContent.length < 50000) {
          google.script.run
              .withSuccessHandler(() => {
                  displayMessage('Saved', {timeout: 1000});
              })
              //   .withFailureHandler((e) => {
              //       console.log('error getting text input');
              //       console.log(e);
              //   })
              .withFailureHandler((error) => {
                  console.error({error});
              })
              .getTextInput(key, sheetName, range, currentNoteContent, dbSheet);
      } else {
          console.error('Contents too long!');
          //   displayMessage("Can't save. Cell note is too long!");
      }
  }

  function updateCellRange(forceUpdate) {
      const dbSheet = state.dbSheet;
      try {
          google.script.run
              .withSuccessHandler(function (data, element) {
                  if (data) {
                      const splitter = data.split('!@!@');
                      const [
                          key,
                          content,
                          sheetName,
                          rangeA1formatted,
                          error,
                      ] = splitter;
                      if (forceUpdate || rangeA1formatted !== state.rangeA1) {
                          //   if (state.rangeA1 !== rangeA1formatted) {
                          // here we will need to save prior to storing new values
                          state.key = key;
                          state.sheetName = sheetName;
                          state.rangeA1 = rangeA1formatted;
                          state.error = error || null;
                          state.prevNote = content;
                          state.currentNote = content;

                          quill.setContents(quill.clipboard.convert(content));
                      }
                      //   const oldError = document.getElementById('error').innerHTML;
  
                      //   displayError(error == 'true', oldError != error);
                      //   document.getElementById('error').innerHTML = error;
                      //CKEDITOR.instances.editor1.setData(content);
                      //   displayMessage('');
                      //   }
                  }
              })
              .withFailureHandler((error) => {
                  console.log({getNoteError: error});
              })
              .getNoteForActiveRange(dbSheet);
      } catch (err) {
          console.error(err);
      }
      poll();
  }

  /**
   * Poll a server-side function at the given interval, to have
   * results passed to a successHandler callback. There's no other
   * means to determine if the user has made changes (namely, changes
   * to cell selection) in client-side code.
   *
   * https://stackoverflow.com/a/24773178/1677912
   *
   * @param {Number} interval   (optional) Time in ms between polls.
   *                            Default is 2s (2000ms)
   */
  function poll({firstPoll = false} = {}) {
      /**
       * TODO: there may be a better way to do this using Quill's editor-change callback;
       * listen for changes in the editor to determine if we should write to the DB; not
       * do it on a polled interval (reading from the DB based on cell selection will likely
       * have to remain in a polling interval)
       * */
      const pollingInterval = 2000;

      setTimeout(function () {
          updateCellRange(firstPoll);
      }, pollingInterval);
  
      setTimeout(function () {
          checkAlive();
          setAlive();
      }, 5000);
  }
</script>

